#!/usr/bin/env python
#
# Copyright (C) distroy
#

import os
import sys
import commands

widths = [1, 8, 8, 8, 11, 6, 8, 13]

scr_width = 0
bcmd_fmt = ""


def getTerminalSize(w = 25, h = 80):
    def ioctl_GWINSZ(fd):
        try:
            import fcntl, termios, struct
            cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))
        except:
            return
        return cr
    cr = ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2)
    import os
    if not cr:
        try:
            fd = os.open(os.ctermid(), os.O_RDONLY)
            cr = ioctl_GWINSZ(fd)
            os.close(fd)
        except:
            pass
    if not cr:
        env = os.environ
        cr = (env.get('LINES', w), env.get('COLUMNS', h))
    return int(cr[1]), int(cr[0])


def init():
    if sys.stdout.isatty():
        # scr_width = int(os.environ.get('COLUMNS', 0))
        width, height = getTerminalSize(0, 0)
        scr_width = width

    global bcmd_fmt
    bcmd_fmt = ''.join(['%%%ds' % i for i in widths]) + ' '

def get_bcmd(arr):
    return bcmd_fmt % tuple(arr[: len(widths)])

def get_depth(depth):
    buff = ''

    for i in range(0, len(depth) - 1):
        if depth[i]:
            buff += ' |  '
        else:
            buff += '    '
    if len(depth):
        buff += ' \_ '

    return buff

def get_cmd(cmd):
    return cmd


def print_line(text):
    s = text

    if sys.stdout.isatty() and scr_width != 0:
        s = s[: scr_width]

    sys.stdout.write('%s\r\n' % s)


def parse_line(line):
    l = []

    start = 0
    for w in widths:
        end = start + w
        l.append(line[start: end].lstrip())
        start = end
    l.append(line[start: ].lstrip())

    return l

def print_head(head):
    buff = ''
    buff += get_bcmd(head)
    buff += get_cmd(head[-1])
    print_line(buff)

def print_tree(root, depth = []):
    text = root['text']
    childs = root['childs']

    buff = ''
    buff += get_bcmd(text)
    buff += get_depth(depth)
    buff += get_cmd(text[-1])
    print_line(buff)

    depth.append(1)
    for i in range(0, len(childs)):
        child = childs[i]
        if i == len(childs) - 1:
            depth.pop()
            depth.append(0)
        print_tree(child, depth)
    depth.pop()

def main():
    init()

    cmd = 'ps ' + ' '.join(sys.argv)
    (ret, output) = commands.getstatusoutput(cmd)
    if ret != 0:
        print (output)
        return ret

    lines = output.split("\n")

    head = parse_line(lines[0])
    if 'PPID' not in head:
        print (output)
        return 0

    tree = {}
    list = []

    for i in lines[1:]:
        text = parse_line(i)

        info = {}
        for i in range(0, len(head)):
            info[head[i]] = text[i]

        proc    = {'info': info, 'childs': [], 'root': 1, 'text': text}
        pid     = info['PID']

        try:
            fd = os.open('/proc/%s/cmdline' % pid, os.O_RDONLY)
            cmd = os.read(fd, 2048)
            cmd = cmd.replace('\0', ' ')
            cmd = cmd.replace('\n', ' ')
            if cmd != '<defunct> ':
                text[-1] = cmd
        except:
            pass

        tree[pid] = proc
        list.append(proc)

    # make tree
    for proc in list:
        ppid = proc['info']['PPID']

        if ppid in tree.keys():
            parent = tree[ppid]
            parent['childs'].append(proc)
            proc['root'] = 0

    # print head
    print_head(head)
    # print tree
    for proc in list:
        if not proc['root']:
            continue

        print_tree(proc)

    return 0

if __name__ == '__main__':
    r = main()
    exit(r)

